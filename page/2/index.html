<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  

  
  <title>fengweizan&#39;s BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="my blog with material design">
<meta property="og:type" content="website">
<meta property="og:title" content="fengweizan&#39;s BLOG">
<meta property="og:url" content="https://fclehly.github.io/page/2/index.html">
<meta property="og:site_name" content="fengweizan&#39;s BLOG">
<meta property="og:description" content="my blog with material design">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="FWZ">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="fengweizan&#39;s BLOG" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">fengweizan&#39;s BLOG</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fclehly.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-RTCP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/05/RTCP/" class="article-date">
  <time datetime="2019-07-05T14:06:52.000Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/05/RTCP/">RTCP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://fclehly.github.io/2019/07/05/RTCP/" data-id="ckogykb1c000lw50t9rs5f931" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RTP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/05/RTP/" class="article-date">
  <time datetime="2019-07-05T14:06:48.000Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/05/RTP/">RTP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://fclehly.github.io/2019/07/05/RTP/" data-id="ckogykb1f000rw50t95o17gts" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RTSP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/05/RTSP/" class="article-date">
  <time datetime="2019-07-05T14:06:42.000Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/05/RTSP/">RTSP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://fclehly.github.io/2019/07/05/RTSP/" data-id="ckogykb1e000nw50tfve9en72" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JMX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/05/JMX/" class="article-date">
  <time datetime="2019-07-05T14:06:26.000Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/05/JMX/">JMX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://fclehly.github.io/2019/07/05/JMX/" data-id="ckogykb14000aw50tcgrpfh5u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Netty" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/05/Netty/" class="article-date">
  <time datetime="2019-07-05T14:06:06.000Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/05/Netty/">Netty</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://fclehly.github.io/2019/07/05/Netty/" data-id="ckogykb19000gw50te9q20xu1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/19/Docker/" class="article-date">
  <time datetime="2019-06-19T14:50:57.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/19/Docker/">Docker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Docker是一个开源的容器引擎，可以将应用软件和应用所需的依赖打包在一起，形成一个标准化单元，类似于Java基于jvm的<em>write once, run anywhere</em>， docker可以实现<em>build once, run anywhere</em>。最近几年，微服务架构火热，而在大型企业中，微服务的运维由于服务的数量比较多而进展困难，容器化服务势在必行。服务容器化使应用程序能够从组件快速组装到发布，消除了开发和QS和IT的摩擦。容器是微服务的基石，没有容器化的微服务是没有灵魂的。docker让容器化操作变得简单，docker的出现让大型的微服务架构得以流行，而微服务的火热又促进了docker发展。</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><blockquote>
<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p>
</blockquote>
<h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><blockquote>
<p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。<br>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
</blockquote>
<h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><blockquote>
<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
</blockquote>
<h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><blockquote>
<p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
</blockquote>
<h2 id="VM-Vagrant-Docker"><a href="#VM-Vagrant-Docker" class="headerlink" title="VM, Vagrant, Docker"></a>VM, Vagrant, Docker</h2><p>最开始，大家就想着直接把整个系统打包再部署，即虚拟机技术，保证了系统和环境的稳定，减少了大量手工操作。但是，缺点也是有的，那就是无法自动化打包过程，于是<a href="https://www.vagrantup.com/">Vargrant</a>被做了出来，Vargrant使用了vargrantfile文件给开发者提供了定义自动化构建VM镜像的功能。但是，还是有缺点，首先，打包出来的镜像太大，包含了过多不需要使用的依赖；其次，服务启动必须等得VM的系统启动完成后才能启动服务。<br>为了解决VM的缺点，Docker被开发了出来，它提供了系统上的进程级别的虚拟化技术。与VM需要虚拟化整个硬件和操作系统不同，Docker是直接基于宿主机的操作系统进行虚拟化，性能几乎没有损耗。具体结构差异如下：</p>
<pre><code>虚拟机：
    +------------+-------------+
    | App A      |  App B      |
    +------------+-------------+
    | Libs       |  Libs       |
    +------------+-------------+
    |Guest OS    |  Guest OS   |
    +------------+-------------+
    |       Hypervisor         |
    +--------------------------+
    |        HOST OS           |
    +--------------------------+
    |         SERVER           |
    +--------------------------+

Docker：
    +------------+-------------+
    | App A      |  App B      |
    +------------+-------------+
    | Libs       |  Libs       |
    +------------+-------------+
    |       Docker Engine      |
    +--------------------------+
    |        HOST OS           |
    +--------------------------+
    |         SERVER           |
    +--------------------------+
</code></pre>
<h2 id="Docker的组成"><a href="#Docker的组成" class="headerlink" title="Docker的组成"></a>Docker的组成</h2><p>docker主要由以下组件组成：</p>
<ul>
<li>docker client</li>
<li>docker daemon</li>
<li>docker image</li>
<li>docker container</li>
<li>docker registry</li>
</ul>
<p>Docker本身是C/S架构，C端是docker client，S端是docker daemon，docker daemon管理者docker image和docker container，docker index提供镜像索引以及用户认证的功能，docker registry在远程存放镜像，大致架构如下：</p>
<pre><code>

                           +-----------------+
                           | Docker Daemon   |
        ,---.              |  -------------- |                )------------------(
       /     \             |  Container1     |                |                  |
      / Docker\            |                 |--------------- |  Docker Registry |
     (  Client )---------- |  Container2     |                |                  |
      \       /            |                 |                )------------------(
       \     /             |  Container3     |                          |
        `---&#39;              |                 |                          |
     docker pull           |  .......        |                          |
     docker run            |                 |                          |
     docker build          +-----------------+                          |
     docker ...                     |                                   |
                                    |                                   |
                            +----------------+                          |
                            |  Docker Index  |--------------------------+
                            +----------------+
</code></pre>
<h3 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h3><p>docker image是docker容器的基石，保存了docker启动的各种条件，docker container的启动必须基于一个docker image。Docker image位于docker生命周期的构建和打包阶段。<br>docker使用了union mount的方式构建镜像，采用了ufs的模型。就是docker一次性加载多个文件系统形成一个文件系统层叠的形式，但是在外部看来容器只有一个文件系统可用，docker将这样的文件系统称为docker image。<br>docker image是一个层层叠加的只读文件系统。最底部是bootfs，即引导文件系统，当容器启动后，引导文件系统将会被卸载。bootfs之上是rootfs，rootfs可以是ubuntu/centos/debian/fedora，与虚拟机启动后由只读状态变为读写状态不同，docker的rootfs永远是只读。</p>
<pre><code>Docker的UFS示例：
 +---------------+
 |  add django   |
 +---------------+
 |  add python3  |
 +---------------+
 |rootfs(ubuntu) |
 +---------------+
 |     bootfs    |
 +---------------+
</code></pre>
<h3 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h3><p>Docker Container是Docker的执行单元，通过镜像来启动。Docker container位于docker生命周期的启动和执行阶段。<br>Docker Container基于镜像启动时，会在镜像构建出的ufs上再添加一个writable layer，一个可写层。当容器刚启动时，该读写层是空的，当容器状态发生改变时，读写层才会有变化。比如当需要修改一个文件时，docker把改文件从下层的只读文件系统中复制到读写层，再进行修改，该文件的只读版本仍然存在，但是已经被读写层上的副本隐藏起来了。这就是Docker中重要的技术<strong>Copy on Write</strong>（中文翻译为写时复制），每个只读镜像层永远都是只读的，不会变化，当创建出一个新容器时，docker会构建出一个镜像栈，在栈的顶层增加读写层，并与底下的只读层和一些数据就构成了一个容器。容器的分层框架能够使我们快速的构建镜像并发布应用程序。</p>
<pre><code>Docker container创建的镜像栈

 +---------------+
 | add my app    |  读写层(copy on write)
 +---------------+
 |  add django   |  Read Only
 +---------------+
 |  add python3  |  Read Only
 +---------------+
 |rootfs(ubuntu) |  Read Only
 +---------------+
 |     bootfs    |  Read Only
 +---------------+
</code></pre>
<h3 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h3><p>Docker仓库分为公有和私有，放着一些已有的镜像，官方的docker registry是<a href="https://www.docker.com/products/docker-hub">Docker Hub</a>。</p>
<h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h3><p>C++中有namespace这个概念，它实现了代码块的封装，更重要的是代码的隔离，使得不同namespace下可以有相同的变量名但意义不同。在linux里，namespace是一个重要的特性，提供了系统资源的隔离，包括进程/网络/文件系统等。linux实现namespace的重要目的就是为了实现轻量级的虚拟化，也就是容器（linux里的lxc了解一下）。在同一namespace下的进程可以感知彼此的变化，而不能发现其他进程，从而使得一个namespace下的进程认为自身处于一个独立的系统中，便达到了独立和隔离的目的。<br>Docker目前用到了以下几种namespace进行资源隔离。</p>
<ul>
<li>PID， Process ID, 进程隔离；</li>
<li>NET， Network， 网络隔离；</li>
<li>IPC， InterProcess Communication， 跨进程通信访问隔离；</li>
<li>MNT， Mount， 挂载点隔离；</li>
<li>UTS， Unix Timesharing System， 内核和版本标识隔离；</li>
<li>USER, 用户和组隔离；</li>
</ul>
<p>而隔离资源的管理就需要用到Control Groups</p>
<h3 id="Control-Groups"><a href="#Control-Groups" class="headerlink" title="Control Groups"></a>Control Groups</h3><p>Control groups是linux提供的限制/记录/隔离主机物理资源的机制，简称cgroups，为了更好的管理容器，cgroups在2007年并入到linux kernel中。没有cgroups，就没有容器。<br>cgroups主要负责容器相关的以下内容：</p>
<ul>
<li>资源限制，比如为进程组设置一个内存使用的上限；</li>
<li>优先级设定，比如为某些进程组设定更大的cpu和内存资源。</li>
<li>资源计量，比如计算进程组使用了多少系统资源。</li>
<li>资源控制，比如将进程组挂起和恢复。</li>
</ul>
<p>正是因为namespaces和cgroups，Docker的容器才拥有了以下能力：</p>
<ul>
<li>文件系统隔离：每个容器都有自己的rootfs；</li>
<li>进程隔离： 每个容器都运行在自己的进程环境中；</li>
<li>网络隔离： 容器间的虚拟网络接口和IP地址都是分离的；</li>
<li>资源隔离和分组： cgroups将CPU和内存等资源独立分配给每个不同的Docker容器。</li>
</ul>
<h3 id="容器的状态"><a href="#容器的状态" class="headerlink" title="容器的状态"></a>容器的状态</h3><ul>
<li>运行</li>
<li>已暂停</li>
<li>重新启动</li>
<li>已退出</li>
</ul>
<h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><pre><code class="bash">$ docker help

$ docker help cp
</code></pre>
<pre><code class="bash">$ docker run --detach --interactive --tty --name web busybox:latest /bin/bash

$ docker run -d -name wp3 --link wpdb:mysql -p 80 -v /run/lock/apache2 -v /run/apache2 --read-only wordpress:4

$ docker run -d --rm --name wp --env MY_ENVIRONMENT_VAR=&quot;test&quot; --read-only wordpress:4

$ docker inspect --format &quot;&#123;&#123;.State.Running&#125;&#125;&quot; wp

$ docker ps

$ docker top web

$ docker run --it

$ docker restart web

$ docker logs web

$ docker exec web ps

$ docker stop xxxx

$ docker search postgres

$ docker save -o myfile.tar busybox:latest

$ docker load -i myfile.tar

$ docker rmi busybox
</code></pre>
<h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><p>类似于Makefile， Docker可以根据Dockerfile来构建镜像。Dockerfile是一个文本文件，每一行都是一个Dockerfile指令。接着使用docker build命令就可以构建出一个docker镜像了。Dockerfile是自动化运维的关键。</p>
<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p>注释</p>
<pre><code># Comment 这是注释
</code></pre>
<p>指令</p>
<pre><code>INSTRUCTION arguments
</code></pre>
<p>样例</p>
<pre><code>FROM ubuntu:16:04
LABEL author=fwz version=1.0.1
WORKDIR /root/myapp
COPY myapp .
RUN apt update \
    &amp;&amp; apt install -y python3 python3-pip
    &amp;&amp; pip3 install -r requirement.txt
EXPOSE 8000
ENTRYPOINT [&quot;/usr/bin/python3&quot;, &quot;/root/app/manage.py&quot;, &quot;runserver&quot;]
</code></pre>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FROM指令指定了一个基础镜像，接下来的指令都是基于这个基础镜像进行构建。每个Dockerfile都必须包含FROM指令。如果FROM指定的基础镜像不在本地，则会从Dockerhub上拉取。</p>
<pre><code>FROM ubuntu:16:04
</code></pre>
<pre><code>FROM python:3.7
</code></pre>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN指令是构建时执行的指令，。格式是<code>RUN &lt;command&gt;</code>或者<code>RUN [&#39;executable&#39;, &#39;param1&#39;, &#39;param2&#39;, ...]</code>，RUN指令默认使用shell执行命令，即<code>/bin/sh -c</code>执行命令，如果想使用不同的shell，比如<code>bash</code>，那么可以像这么写：</p>
<pre><code>RUN [&#39;/bin/bash&#39;, &#39;-c&#39; &#39;python3 bootstrap.py&#39;]
</code></pre>
<p>而且最好RUN指令的内容都写在同一行，防止ufs的层数过多。</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD指令是容器启动时执行的指令，可以包含参数，比如：</p>
<pre><code>CMD [&quot;python3&quot;, &quot;manage.py&quot;, &quot;runserver&quot;, &quot;0.0.0.0:8000&quot;]
</code></pre>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>用于指定容器监听的内部端口号，不过可以在<code>docker run</code>的时候更改端口映射；</p>
<pre><code>EXPOSE 27017
</code></pre>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>把文件从本地复制到容器中</p>
<pre><code>COPY application.yml /app/
</code></pre>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>和CMD类似，也是容器启动时执行的命令，不过可以在容器启动即<code>docker run</code>时提供参数</p>
<pre><code>ENTRYPOINT [&quot;java&quot;, &quot;app.jar&quot;]
</code></pre>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>记录容器相关的变量，<code>docker inspect</code>时可以看到</p>
<pre><code>LABEL author=&quot;菜徐坤&quot; version=&quot;7.7.7&quot;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fclehly.github.io/2019/06/19/Docker/" data-id="ckogykb110004w50tf2qcb6pv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Config-Center-Apollo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/18/Config-Center-Apollo/" class="article-date">
  <time datetime="2019-06-18T12:32:05.000Z" itemprop="datePublished">2019-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/18/Config-Center-Apollo/">Config Center: Apollo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>随着微服务的流行，应用和机器数量急剧增长，程序配置也愈加繁杂：各种功能的开关、参数的配置、服务器的地址等等。同时，我们对程序配置的期望值也越来越高：配置修改后实时生效，灰度发布，分环境、分集群管理，完善的权限、审核机制等等。</p>
<p>一般服务部署到线上之后，当程序发布到生产环境后，一般就是按照预设的逻辑运行，我们无法直接去干预程序的行为，不过可以通过调整配置参数来动态调整程序的行为。</p>
<p>在Spring Cloud的微服务架构方案中虽然提供了Spring Cloud Config来担任配置中心的角色，但是该项目的功能在配置的管理层面还是非常欠缺的。初期我们可以依赖选取的配置存储系统（比如：Gitlab、Github、Gerrit）给我们提供的配置管理界面来操作所有的配置信息，但是这样的管理还是非常粗粒度的。</p>
<p>spring cloud config使用git作分布式配置管理仓库，虽然比较便捷，但是也有一些缺点，比如：修改配置的操作需要修改clone下来的仓库然后再commit和push，缺少通过web界面修改配置的手段；配置需要生效的话，则要求服务重启或者refresh或者git hooks回调等；另外版本管理也是没有比较好的web界面的，只能通过在命令行上使用git命令。授权和审核操作gerrit和gitlab是有提供的，但是粒度比较粗，修改和发布权限没有比较好的分离。在生产环境上，每个服务正在使用什么配置，往往只能靠记忆，很不方便。</p>
<p>spring cloud config既然推荐了git，自然是有优点的，最重要的一点就是足够简单，另外由于缺乏了很多功能，开发人员能开展个性化的开发因而扩展性极强。这就够了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fclehly.github.io/2019/06/18/Config-Center-Apollo/" data-id="ckogykb100003w50t746l1rs8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Ansible" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/01/Ansible/" class="article-date">
  <time datetime="2019-06-01T13:48:11.000Z" itemprop="datePublished">2019-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/01/Ansible/">Ansible</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ANSIBLE"><a href="#ANSIBLE" class="headerlink" title="ANSIBLE"></a>ANSIBLE</h1><hr>
<p>[TOC]</p>
<hr>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>为了操作远程主机，我们通常是ssh登录到对应的机子上并输入命令执行，安装软件、修改配置、等等。如果只有单台主机，这么做是完全OK的，顶多是把一些常用操作变成脚本减少重复操作。但是当有了两台主机甚至更多主机之后，同样的命令在另一台主机还要敲一遍，这样的操作就有点枯燥繁琐了。有的人觉得仅仅是多一台主机还好，那如果多10台主机呢，比如需求是在10台机子上配置redis集群，那么ssh登录到每台机子上进行操作是一件很sb的事。</p>
<p>一个简单的解决方案是：使用pssh。pssh可以通过ssh的方式批量发送命令到多台主机并执行，pscp可以批量拷贝文件到多台主机。但是pssh的缺点也很明显，就是功能太少。如果想要通过pssh进行复杂的操作，那就比较困难了。</p>
<p>多主机的配置管理是常见的场景，前人已经造好了轮子，也就是一些自动化运维工具，我们直接使用就行了。比较著名的也是国内用的最多的就是Ansible。</p>
<p>其实本质上Ansible或者说大部分运维工具主要解决以下自动化运维场景：</p>
<ul>
<li>文件传输</li>
<li>应用部署</li>
<li>配置管理</li>
<li>任务流编排</li>
</ul>
<h2 id="常用自动化运维工具"><a href="#常用自动化运维工具" class="headerlink" title="常用自动化运维工具"></a>常用自动化运维工具</h2><p>自动化运维工具主要可以分为两大类：</p>
<ol>
<li>需要装代理的；</li>
<li>不需要装代理的；</li>
</ol>
<p>第一种方式是指我们需要预先在目标主机上安装代理软件（在被控端上放个内鬼，就可以交易了），然后主控端通过通知代理软件来操纵被控端。</p>
<p>第二种方式是不需要在被控端安装代理软件，主要是通过ssh连接到被控主机进行控制操作，主控端需要提前得到被控主机的授权（比如秘钥对）才能进行相应的操作。</p>
<p>当前主流的自动化运维工具有：</p>
<ul>
<li>ansible：使用python编写，agentless，适用于中小型应用环境；</li>
<li>saltstack： 使用python编写，需要在每台机子上安装agent，执行效率更高；</li>
<li>puppet： 使用ruby编写，功能强大，配置复杂，重型，适合大型环境；</li>
<li>fabric：使用python编写，agentless，功能比较简单；</li>
</ul>
<p>由于puppet是使用ruby编写的，国内ruby玩家的数量远少于python，因此saltstack和ansible的使用者相对来说就比较多。fabric由于功能太少，完全能被ansible替代，所以企业用户很少使用fabric做复杂的任务流编排。</p>
<h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>这里简单说一下ansible的主要特性：</p>
<ul>
<li>模块化：调用特定的模块，完成特定的任务，比如说rabbitmq模块特定用于部署rabbitmq，redis模块特定用户部署redis等；</li>
<li>有paramiko，pyyaml，jinja2三个关键模块，分别的功能是ssh连接并操作，解析yaml文件，jinjia2模板引擎；</li>
<li>支持自定义模块；</li>
<li>基于python实现；</li>
<li>部署简单，基于python和ssh，agentless；</li>
<li>安全，基于openssh；</li>
<li>支持playbook编排任务；</li>
<li>幂等性，第一次执行某个ansible的操作和第n次执行同样的ansible操作对主机状态的改变结果是一样的；</li>
<li>无需代理不依赖pki；</li>
<li>可使用任何语言写模块；</li>
<li>yaml格式，编排任务，支持丰富的数据结构；</li>
<li>较强大的多层解决方案；</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>只要用pip安装即可。</p>
<pre><code class="shell">&gt; pip install ansible
</code></pre>
<p>或者</p>
<pre><code>&gt; pip3 install ansible
</code></pre>
<p>完成。</p>
<p>配置文件主要在：</p>
<ol>
<li><code>/etc/ansible/ansible.cfg</code>，ansible工具本身的配置。</li>
<li><code>/etc/ansible/hosts</code>，静态主机清单（Inventory）配置。</li>
<li><code>/etc/ansible/roles/</code>，ansible-roles可以放在这。</li>
</ol>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="Inventory"><a href="#Inventory" class="headerlink" title="Inventory"></a>Inventory</h4><p>主机清单。对于批量主机操作，为了便捷的使用其中的部分主机，可以在inventory file中将其分组命名，默认的inventory file为<code>/etc/ansible/hosts</code>，inventory file可以有多个，且也可以通过Dynamic Inventory来动态生成。inventory文件的格式符合<code>INI</code>文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；如果目标主机使用非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来表明。举个例子：</p>
<pre><code>[webserver]
172.1.1.40:2222
10.2.2.2
www.bbb.com

# 主机机名遵循相似的命名模式，还可使用列表的方式标识个主机
[mysqlserver]
db[01:10].dddd.com

[redisserver]
rds-[a:f].cloud.com

# 在inventory中定义主机时为其添加主机变量以便于在playbook中使用
[appserver]
10.3.3.3 maxMemoryUsage=60
10.4.4.4 servicePort=8099

# 定义指定组内所有主机上的在playbook中可用变量
[appsever:vars]
config-center=172.3.4.5
enable-water=true
</code></pre>
<h4 id="AD-Hoc"><a href="#AD-Hoc" class="headerlink" title="AD-Hoc"></a>AD-Hoc</h4><p>命令行模式使用ansible。</p>
<p>使用<code>ansible --help</code>可查看如何使用</p>
<pre><code class="shell">fwz@fwz-mbp ~/Workspace&gt; ansible --help
Usage: ansible &lt;host-pattern&gt; [options]

Define and run a single task &#39;playbook&#39; against a set of hosts

Options:
  -a MODULE_ARGS, --args=MODULE_ARGS
                        module arguments
  --ask-vault-pass      ask for vault password
  -B SECONDS, --background=SECONDS
                        run asynchronously, failing after X seconds
                        (default=N/A)
  -C, --check           don&#39;t make any changes; instead, try to predict some
                        of the changes that may occur
  -D, --diff            when changing (small) files and templates, show the
                        differences in those files; works great with --check
......
......
</code></pre>
<p>简单的说，语法就是<code>ansible &lt;host-pattern&gt; [-f forks] [-m module_name] [-a args]</code></p>
<p>本质上，就是调用相应的ansible模块，并传入相应的参数。</p>
<p>举几个例子:</p>
<p>ping所有主机（使用ping模块）：</p>
<pre><code class="shell">&gt; ansible all -a ping --ask-pass
ansible all -m ping --ask-pass
SSH password:
xx.xx.xx.xxx | SUCCESS =&gt; &#123;
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
&#125;
</code></pre>
<p>改变文件属性（使用file模块）:</p>
<pre><code class="shell">&gt; ansible mysql-server -m file -a &#39;owner=mysql group=mysql mode=644 path=/tmp/fstab.ansible&#39;
</code></pre>
<p>拷贝文件（使用copy模块）:</p>
<pre><code class="shell">&gt; ansible storageIndex-server -m copy -a &#39;src=/home/devops/cloud-relay-1.2.4-SNAPSHOT.tar.gz dest=/root/cloud-storageIndex/cloud-relay-1.2.4.tar.gz&#39;
</code></pre>
<p>配置Rabbitmq（使用rabbitmq_user模块）:</p>
<pre><code class="shell">&gt; ansible rabbitmq-server -m rabbitmq_user -a &#39;user=new_user password=root tags=administrator vhost=/ state=present&#39;
</code></pre>
<p>执行linux的命令（使用shell模块）：</p>
<pre><code class="shell">&gt; ansible webserver -m shell -a &#39;netstat -nutlp &gt; netstat_temp.txt&#39;
</code></pre>
<h4 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a>Playbook</h4><p>剧本。虽然可以在命令行中使用ansible，但是明显功能有限，无法支持复杂环境的配置管理工作。首先，命令行一次只能执行一条命令，其次，由于通常是手敲命令，因此不好重复。类似于linux中的shell脚本，ansible提供了playbook，翻译为剧本，用于组织基于多个ansible模块交互的工作流编排。</p>
<p>linux的脚本文件是<code>.sh</code>文件，ansible-playbook则是<code>.yaml</code>文件，即使用YAML语法。YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。</p>
<p>直接举个例子：</p>
<pre><code class="yaml">---
# This playbook will install mysql and create db user and give permissions.
- hosts: $servername
  remote_user: root
  - name: Install Mysql package
    yum: name=&#123;&#123; item &#125;&#125; state=installed
    with_items:
     - mysql-server
     - MySQL-python
     - libselinux-python
     - libsemanage-python

  - name: Configure SELinux to start mysql on any port
    seboolean: name=mysql_connect_any state=true persistent=yes
    when: sestatus.rc != 0

  - name: Create Mysql configuration file
    template: src=my.cnf.j2 dest=/etc/my.cnf
    notify:
    - restart mysql

  - name: Start Mysql Service
    service: name=mysqld state=started enabled=yes

  - name: insert iptables rule
    lineinfile: dest=/etc/sysconfig/iptables state=present regexp=&quot;&#123;&#123; mysql_port &#125;&#125;&quot;
                insertafter=&quot;^:OUTPUT &quot; line=&quot;-A INPUT -p tcp  --dport &#123;&#123; mysql_port &#125;&#125; -j  ACCEPT&quot;
    notify: restart iptables

  - name: Create Application Database
    mysql_db: name=&#123;&#123; dbname &#125;&#125; state=present

  - name: Create Application DB User
    mysql_user: name=&#123;&#123; dbuser &#125;&#125; password=&#123;&#123; upassword &#125;&#125; priv=*.*:ALL host=&#39;%&#39; state=present
</code></pre>
<p>例子很好理解，首先是定义了这个playbook在哪个主机组中执行，以及对应的用户，接着是一组task，分别调用了yum、seboolean、template、service、lineinfile、mysql_db、mysql_user模块。其中使用了notify作handler。</p>
<p>hosts：playbook中的每一个play的目的都是为了让某个或某些主机以某个指定的用户身份执行任务。hosts用于指定要执行指定任务的主机，其可以使一个或多个由冒号分隔主机组；</p>
<p>remote_user: remote_user也可用于各task中，也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或其任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户。</p>
<p>task：play的主题部分是task list。task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后再开始第二个。在运行自上而下某playbook时，如果中途发生错误，所有已执行任务都可能回滚，在更正playbook后重新执行一次即可。</p>
<p>taks的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的。这意味着多次执行是安全的，因为其结果均一致。</p>
<p>每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤，如果为提供name，则action的结果将用于输出。</p>
<p>定义task可以使用”action: module options”或”module：options“的格式推荐使用后者以实现向后兼容。如果action一行的内容过多，也中使用在行首使用几个空白字符进行换行。</p>
<pre><code class="yaml">tasks:
 - name:make sure apache is running
   service: name=httpd state=started
</code></pre>
<p>在众多的模块中，只有command和shell模块仅需要给定一个列表而无需使用”key=value”格式</p>
<pre><code class="yaml">tasks:
 - name: run this command and ignore the result
   shell: /usr/bin/somecommand || /bin/true
</code></pre>
<p>Handler: 用于当关注的资源发生变化时采取一定的操作。</p>
<p>“notify”这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时每次都执行执行的操作，取而代之，仅在所有的变化发生完成后一次性地执行指定操作，在notify中列出的操作称为handlers，也即notify中调用handlers中定义的操作。</p>
<pre><code class="yaml">- name: template configuration file
 template: src=template.j2 dest=/etc/foo.conf
 notify:
   - restart memcached
   - restart apache
</code></pre>
<h4 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h4><p>ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动转载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板以及处理器放置于单独的目录中，并可以便捷地include他们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以使用于构建守护进程的场景中。</p>
<p>一个常用的role结构：</p>
<pre><code class="shell">site.yml
webserver.yml
fooserver.yml
roles/
   common/
       files/
       templates/
       tasks/
       handlers/
       vars/
       meta/
   webserver/
       files/
       templates/
       tasks/
       handlers/
       vars/
       meta/
</code></pre>
<p>在ansible-playbook中可以这么使用role：</p>
<pre><code class="yaml">- hosts: webserver
 roles:
   - common  
   - webserver
</code></pre>
<p>向role中传递参数：</p>
<pre><code class="yaml">- hosts: webserver
 roles:
   - common
   - &#123; role: foo_app_instance, dir:&#39;/opt/a&#39;,port:5000&#125;
   - &#123; role: foo_app_instance, dir:&#39;/opt/b&#39;,port:5001&#125;
</code></pre>
<ul>
<li>task目录：至少应该包含一个为main.yml的文件，其定义了此角色的任务列表；此文件可以使用include包含其它的位于此目录中的task文件；</li>
<li>file目录：存放由copy或script等模板块调用的文件；</li>
<li>template目录：template模块会自动在此目录中寻找jinja2模板文件；</li>
<li>handlers目录：此目录中应当包含一个main.yml文件，用于定义此角色用到的各handlers，在handler中使用inclnude包含的其它的handlers文件也应该位于此目录中；</li>
<li>vars目录：应当包含一个main.yml文件，用于定义此角色用到的变量</li>
<li>meta目录：应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；ansible1.3及其以后的版本才支持；</li>
<li>default目录：应当包含一个main.yml文件,用于为当前角色设定默认变量时使用此目录；</li>
</ul>
<p>官方提供了很多ansible-roles的例子：<a href="https://github.com/ansible">ansible/<strong>ansible-examples</strong></a></p>
<h4 id="Galaxy"><a href="#Galaxy" class="headerlink" title="Galaxy"></a>Galaxy</h4><p>用于分享和下载ansible-role的平台，类似于同性交友网站github。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fclehly.github.io/2019/06/01/Ansible/" data-id="ckogykb0s0000w50tai1n3ziv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/devops/" rel="tag">devops</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Points-on-Serverless" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/01/Points-on-Serverless/" class="article-date">
  <time datetime="2019-01-01T05:09:00.000Z" itemprop="datePublished">2019-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Blog/">Blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/01/Points-on-Serverless/">Points on Serverless</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于Serverless架构"><a href="#关于Serverless架构" class="headerlink" title="关于Serverless架构"></a>关于Serverless架构</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>最近写的项目其中一个功能点用到了阿里云的函数计算（function computing， 简称fc）。fc属于<a href="https://en.wikipedia.org/wiki/Serverless_computing">serverless computing</a>架构模式，是一种新兴的云计算架构，在云计算中也被描述为Faas（Function as a Service）,在2014年Amzon首先推出了AWS Lambda，之后各大主流云厂商跟进，在2016年也分别推出了自家的serverless服务，比如阿里的fc和腾讯的scf等。</p>
<blockquote>
<p>阿里云函数计算是事件驱动的全托管计算服务。通过函数计算，您无需管理服务器等基础设施，只需编写代码并上传。函数计算会为您准备好计算资源，以弹性、可靠的方式运行您的代码，并提供日志查询、性能监控、报警等功能。借助于函数计算，您可以快速构建任何类型的应用和服务，无需管理和运维。而且，您只需要为代码实际运行所消耗的资源付费，代码未运行则不产生费用。</p>
</blockquote>
<h2 id="什么是serverless-computing"><a href="#什么是serverless-computing" class="headerlink" title="什么是serverless computing"></a>什么是serverless computing</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>serverless computing是指开发者在构建和运行应用时无需管理服务器等基础设施。应用被解耦为细粒度的函数，函数是部署和运行的基本单位。用户只为实际使用的资源付费。serverless computing能够帮助应用开发者摆脱服务器等底层基础设施管理的负担，专注于业务层的创新。<strong>Serverless不是真的不需要服务器了,而是不用过多的关注服务器</strong>。在微服务的架构下，系统被拆分为一系列独立的服务，serverless的粒度更小，更组件化。</p>
<p>serverless函数是基于容器运行的，每个函数实例的运行时环境都由容器提供；每一次函数被调用都会serverless里的调度器都会首先首先查找可用容器，没有可用容器则会创建一个容器并拉取代码来运行函数，这就是冷启动，冷启动比较耗时。</p>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>计算的发展演进：</p>
<pre><code>物理机 --&gt; 虚拟机 --&gt; 云计算 --&gt; 容器 --&gt; serverless
</code></pre>
<p>云计算：</p>
<pre><code>-------------
|   FaaS    |
-------------
|   Saas    |
-------------
|   Pass    |
-------------
|   IaaS    |
-------------
</code></pre>
<p>从大型物理机到通过虚拟化技术把物理机虚拟成单个的VM资源，从虚拟化集群到把集群搬到云计算上只做简单运维，再到把每一个VM按照运行空间最小化切分成更细的Docker容器，再从Doceker容器变成直接不用管理任何运行环境的Serverless服务。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li><strong>节约使用成本</strong>; 虚拟机通常并不能满负载运行，有一些资源浪费。</li>
<li><strong>简化设备运维</strong>; 无需维护基础设施；</li>
<li><strong>实现快速上线</strong>; 部署只需要几步操作；</li>
<li><strong>降低开发成本</strong>; 只需要关注业务代码（java除外）和相关组件；</li>
<li><strong>自动扩展能力</strong>;</li>
</ol>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol>
<li><strong>缺乏调试和开发工具</strong>;</li>
<li><strong>不适合长时间运行应用</strong>; serverless函数都有最长运行时间限制；</li>
<li><strong>完全依赖云厂商</strong>;</li>
<li><strong>冷启动时间</strong>; serverless函数第一次启动非常耗时；</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Serverless_computing">serverless-computing-wikipedia</a></p>
<p><a href="https://serverless.com/">serverless.com</a></p>
<p><a href="https://github.com/phodal/serverless">Serverless 架构应用开发指南</a></p>
<p><a href="https://help.aliyun.com/product/50980.html?spm=a2c4g.11186623.6.540.5e6f29e96KK0Ji">函数计算-阿里云</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fclehly.github.io/2019/01/01/Points-on-Serverless/" data-id="ckogykb1a000hw50thslp57af" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/function/" rel="tag">function</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/serverless/" rel="tag">serverless</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Thinking-in-Function-Programming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/16/Thinking-in-Function-Programming/" class="article-date">
  <time datetime="2018-12-16T07:23:36.000Z" itemprop="datePublished">2018-12-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Turtorial/">Turtorial</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/16/Thinking-in-Function-Programming/">Thinking in Function Programming</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Thinking-in-Function-Programming"><a href="#Thinking-in-Function-Programming" class="headerlink" title="Thinking in Function Programming"></a>Thinking in Function Programming</h1><h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><blockquote>
<p>TODO: explain it</p>
</blockquote>
<h3 id="No-Side-Effect"><a href="#No-Side-Effect" class="headerlink" title="No Side Effect"></a>No Side Effect</h3><blockquote>
<p>TODO: explain it</p>
</blockquote>
<h3 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h3><blockquote>
<p>TODO: explain it</p>
</blockquote>
<h3 id="Lazy-Evaluation"><a href="#Lazy-Evaluation" class="headerlink" title="Lazy Evaluation"></a>Lazy Evaluation</h3><blockquote>
<p>TODO: explain it</p>
</blockquote>
<h3 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h3><blockquote>
<p>TODO: explain it</p>
</blockquote>
<h2 id="Implements"><a href="#Implements" class="headerlink" title="Implements"></a>Implements</h2><h3 id="In-Python"><a href="#In-Python" class="headerlink" title="In Python"></a>In Python</h3><blockquote>
<p>Python并不是函数式编程语言, 只是支持一些函数式编程的特性</p>
</blockquote>
<h3 id="In-Java"><a href="#In-Java" class="headerlink" title="In Java"></a>In Java</h3><p>Java在8之前不支持函数式编程。Java8新增Stream API支持以一种声明的方式处理数据；<br>例如：</p>
<pre><code class="java">// java11
var list = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;1&quot;);
var listUpper = list.parallelStream()
                    .filter(s -&gt; !s.isEmpty())
                    .map(s -&gt; s.toUpperCase())
                    .collect(Collectors.toList());
var sortedList = list.stream()
                    .sorted()
                    .collect(Collectors.joining(&quot;,&quot;));
</code></pre>
<h3 id="In-JS"><a href="#In-JS" class="headerlink" title="In JS"></a>In JS</h3><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html">Why Functional Programming Matters</a>; </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fclehly.github.io/2018/12/16/Thinking-in-Function-Programming/" data-id="ckogykb1i000yw50t0mve4pvb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Note/">Note</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Paper/">Paper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Turtorial/">Turtorial</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/media/">media</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/os/">os</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/server/">server</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Deep-Learning/" rel="tag">Deep Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLM/" rel="tag">NLM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLP/" rel="tag">NLP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper/" rel="tag">Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/audio/" rel="tag">audio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/devops/" rel="tag">devops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/" rel="tag">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/function/" rel="tag">function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/loadbalance/" rel="tag">loadbalance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lvs/" rel="tag">lvs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/" rel="tag">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/media/" rel="tag">media</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/note/" rel="tag">note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading/" rel="tag">reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/serverless/" rel="tag">serverless</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/video/" rel="tag">video</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Deep-Learning/" style="font-size: 20px;">Deep Learning</a> <a href="/tags/NLM/" style="font-size: 10px;">NLM</a> <a href="/tags/NLP/" style="font-size: 10px;">NLP</a> <a href="/tags/Paper/" style="font-size: 10px;">Paper</a> <a href="/tags/audio/" style="font-size: 10px;">audio</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/devops/" style="font-size: 10px;">devops</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/function/" style="font-size: 10px;">function</a> <a href="/tags/hadoop/" style="font-size: 10px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/loadbalance/" style="font-size: 10px;">loadbalance</a> <a href="/tags/lvs/" style="font-size: 10px;">lvs</a> <a href="/tags/mac/" style="font-size: 10px;">mac</a> <a href="/tags/media/" style="font-size: 10px;">media</a> <a href="/tags/note/" style="font-size: 10px;">note</a> <a href="/tags/reading/" style="font-size: 10px;">reading</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/serverless/" style="font-size: 10px;">serverless</a> <a href="/tags/video/" style="font-size: 10px;">video</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/27/Unittest/">Unittest</a>
          </li>
        
          <li>
            <a href="/2021/05/05/Media-Basic/">Media-Basic</a>
          </li>
        
          <li>
            <a href="/2020/06/28/go-slice/">go slice</a>
          </li>
        
          <li>
            <a href="/2019/10/07/homebrew/">homebrew</a>
          </li>
        
          <li>
            <a href="/2019/09/28/Django/">Django</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 FWZ<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>